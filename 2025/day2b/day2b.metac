function main() {
  printf("Result: %d\n", findRanges() or catch(e) {
    printf("Error! %s\n", e.message)
    return 1
  })
}

function findRanges(): number | error {
  const ranges = split(STDIN, ",")?
  let invalidSum = 0

  for const range in ranges {
    const bounds = split(range, "-")?
      .map(parseNumber)?
      .assert(x => x.size() == 2, "Invalid range expression: ${range}")?

    const [start, end] = bounds

    for const x in seq(start, end) {
      if hasRepeatingDigits("${x}") {
        invalidSum += x
      }
    }
  }

  return invalidSum
}

// IDs are invalid when they are some digit sequence repeated at least twice.
function hasRepeatingDigits(input: string): boolean {
  const size = input.size()
  if size<2 { return false }

  // divisor: number with range(1,size-1)
  for const divisor in seq(1,size-1).filter(x => size%x==0) {
    let ok = true
    // i: number with range(<divisor>,size-1) = number with range(1,size-1) 
    for const i in seq(divisor, size-1) {
      if input[i] != input[i-divisor] { // string access is proven at compile time due to range bounds
        ok = false
        break
      }
    }
    if ok { return true }
  }
  return false
}
